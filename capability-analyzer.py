import argparse, os, sys
import logic.auxiliary as aux_mod
import logic.parser as parser_mod
import output.graph as graph_mod
import output.print as print_mod
import output.save_to_file as save_to_file_mod

def information_search(base_path, depth, search_term):
    file_data = {}

    path_splitted = base_path.split(os.sep)
    basepath_depth = len(path_splitted) - 1
    desired_depth = basepath_depth + depth -1

    for root, dirs, files in os.walk(base_path):
        for entry in files:
            path = file_path = os.path.join(root, entry)

            if desired_depth >= basepath_depth:
                path_splitted = file_path.split(os.sep)
                path = ""
                for i in range(desired_depth):
                    if i < len(path_splitted):
                        path += path_splitted[i] + os.sep

            if search_term == "imports":
                if entry.endswith('.java') or entry.endswith('.kt'):
                    if path not in file_data:
                        file_data[path] = parser_mod.get_imports(file_path)
                    else:
                        file_data[path] += parser_mod.get_imports(file_path)
            elif search_term == "permissions":
                if entry == "AndroidManifest.xml":
                    if path not in file_data:
                        file_data[path] = parser_mod.get_permissions(file_path)
                    else:
                        file_data[path] += parser_mod.get_permissions(file_path)

    for path, values in file_data.items():
        file_data[path] = list(set(values))
        file_data[path].sort()

    sorted_file_data = dict(sorted(file_data.items(), key = lambda kv: (kv[0], kv[1])))

    return sorted_file_data

def main(args):
    for search_term in args.search:
        data = information_search(args.path, args.depth, search_term)

        if not args.no_print:
            print()
            print('------------------------------------------------------------')
            print()
            print(search_term + ':')
            print()
            print_mod.print_tree(data)

        ordered_distribution = aux_mod.get_data_frequency(data)
        if args.graph == "barplot":
            graph_mod.bar_plot(ordered_distribution, args.limit)
        elif args.graph == "horizontal_barplot":
            graph_mod.horizontal_bar_plot(ordered_distribution, args.limit)

        if args.txt:
            save_to_file_mod.save_to_txt(data, args.txt, search_term)
        if args.json:
            save_to_file_mod.save_to_json(data, args.json, search_term)
        if args.frequency:
            save_to_file_mod.save_frequency(ordered_distribution, args.frequency, search_term)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Analyze Android source code capabilities')
    parser.add_argument('path', type=aux_mod.check_path, help='path to the folder containing the source code. It can be a folder containing subfolders')
    parser.add_argument('-s', '--search', type=str, choices=["imports", "permissions"], nargs='+', default=["imports", "permissions"], help='specifies what will be analyzed from the application code')
    parser.add_argument('-d', '--depth', type=int, default=1, help='path depth to aggregate results. A depth of 1 aggregates the results to the selected folder, a depth of 2 aggregates the results to the immediate subfolders, etc.')
    parser.add_argument('-n', '--no-print', action='store_true', help='hide terminal output')
    parser.add_argument('-t', '--txt', type=str, help='save results to <TXT>.txt')
    parser.add_argument('-j', '--json', type=str, help='save results to <JSON>.json')
    parser.add_argument('-f', '--frequency', type=str, help='save frequency results to <FREQUENCY>.txt')
    parser.add_argument('-g', '--graph', type=str, choices=["barplot", "horizontal_barplot"], help='generate a specific type of graph to graphically show the result')
    for arg in sys.argv:
        if arg.startswith('-g') or arg.startswith('--graph') or arg.startswith('-h') or arg.startswith('--help'):
            parser.add_argument('-l', '--limit', type=aux_mod.check_positive, required=True, help='only <LIMIT> number of columns will be shown on graphs')
            break
    args = parser.parse_args()

    main(args)