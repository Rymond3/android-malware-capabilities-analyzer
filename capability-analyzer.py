import argparse, os, sys
import input.read_from_file as rff
import logic.utils as utl
import logic.parser as prs
import output.graph as gph
import output.print as pnt
import output.save_to_file as stf

def capabilities_search(base_path, depth, search_terms):
    file_capabilities = {}

    path_splitted = base_path.split(os.sep)
    basepath_depth = len(path_splitted) - 1
    desired_depth = basepath_depth + depth -1

    for root, dirs, files in os.walk(base_path):
        for entry in files:
            path = file_path = os.path.join(root, entry)

            if desired_depth >= basepath_depth:
                path_splitted = file_path.split(os.sep)
                path = ""
                for i in range(desired_depth):
                    if i < len(path_splitted):
                        path += path_splitted[i] + os.sep

            if path not in file_capabilities:
                file_capabilities[path] = {}
                for st in search_terms:
                    file_capabilities[path][st] = []

            if entry == "AndroidManifest.xml":
                if "permissions" in search_terms:
                    file_capabilities[path]["permissions"] += prs.get_permissions(file_path)
                if "actions" in search_terms:
                    file_capabilities[path]["actions"] += prs.get_actions(file_path)
                if "package" in search_terms:
                    file_capabilities[path]["package"] += prs.get_package(file_path)
            elif entry.endswith('.java') or entry.endswith('.kt'):
                if "imports" in search_terms:
                    file_capabilities[path]["imports"] += prs.get_imports(file_path)

    for path in file_capabilities:
        for search_term, values in file_capabilities[path].items():
            file_capabilities[path][search_term] = list(set(values))
            file_capabilities[path][search_term].sort()

    sorted_file_capabilities = dict(sorted(file_capabilities.items(), key = lambda kv: (kv[0], kv[1])))

    return sorted_file_capabilities

def capabilities_descriptions(dictionary):
    capabilities = rff.read_from_json("capabilities.json")
    desc = {}

    for path in dictionary:
        desc[path] = {}
        for search_term, values in dictionary[path].items():
            desc[path][search_term] = []
            for v in values:
                new_cap = {}
                new_cap['id'] = v
                new_cap['description'] = ""
                new_cap['group'] = []
                found = False
                for cap in capabilities[search_term]:
                    if not found and v.endswith(cap['id']):
                        found = True
                        new_cap['description'] = cap['description']

                        if 'group' in cap and cap['group'] != "":
                            for g in cap['group'].split('|'):
                                for b in capabilities['permission-groups']:
                                    if g == b['id']:
                                        new_dict = {}
                                        new_dict['id'] = b['id']
                                        new_dict['description'] = b['description']
                                        new_cap['group'].append(new_dict)

                desc[path][search_term].append(new_cap)

    return desc

def main(args):
    capabilities = capabilities_search(args.path, args.depth, args.search)

    if args.info:
        cap_descriptions = capabilities_descriptions(capabilities)

    if not args.no_print:
        if args.info:
            pnt.print_descriptions_tree(cap_descriptions)
        else:
            pnt.print_tree(capabilities)

    ordered_distribution = utl.get_data_frequency(capabilities, args.search)
    if args.graph and args.limit:
        gph.plot(ordered_distribution, args.graph, args.limit, args.search)
    
    if args.txt:
        stf.save_to_txt(capabilities, args.txt, args.search)
    if args.json:
        if args.info:
            stf.save_descriptions(cap_descriptions, args.json, args.search)
        else:
            stf.save_to_json(capabilities, args.json, args.search)
    if args.frequency:
        stf.save_frequency(ordered_distribution, args.frequency, args.search)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Analyze Android source code capabilities')
    parser.add_argument('path', type=utl.check_path, help='path to the folder containing the source code. It can be a folder containing subfolders')
    parser.add_argument('-s', '--search', type=str, choices=["package", "permissions", "actions", "imports"], nargs='+', default=["package", "permissions", "actions", "imports"], help='specifies what will be analyzed from the application code')
    parser.add_argument('-d', '--depth', type=int, default=1, help='path depth to aggregate results. A depth of 1 aggregates the results to the selected folder, a depth of 2 aggregates the results to the immediate subfolders, etc.')
    parser.add_argument('-i', '--info', action='store_true', help='append description information to the found capabilities')
    parser.add_argument('-n', '--no-print', action='store_true', help='hide terminal output')
    parser.add_argument('-t', '--txt', type=str, nargs='?', const='results', help='save results to <TXT>.txt')
    parser.add_argument('-j', '--json', type=str, nargs='?', const='results', help='save results to <JSON>.json')
    parser.add_argument('-f', '--frequency', type=str, nargs='?', const='results', help='save frequency results to <FREQUENCY>.txt')
    parser.add_argument('-g', '--graph', type=str, choices=["barplot", "horizontal_barplot"], nargs='?', const="horizontal_barplot", help='generate a specific type of graph to graphically show the result')
    parser.add_argument('-l', '--limit', type=utl.check_positive, default=20, help='only <LIMIT> number of columns will be shown on graphs')
    
    args = parser.parse_args()

    main(args)